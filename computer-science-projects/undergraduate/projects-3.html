<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <title>Undergraduate</title>
		<link href="../img/SCM_logo.png" rel="icon" type="image/x-icon" 
        <meta name="description" content="">
		<!-- Mobile Specific Meta -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        
        <!-- <link rel="shortcut icon" href="img/favicon.png"> -->
        
        <link href='http://fonts.googleapis.com/css?family=Lato:300,400,700' rel='stylesheet'>
        
        <!-- Syntax Highlighter -->
        <link rel="stylesheet" type="text/css" href="../syntax-highlighter/styles/shCore.css" media="all">
        <link rel="stylesheet" type="text/css" href="../syntax-highlighter/styles/shThemeDefault.css" media="all">
		
		<!-- Font Awesome CSS-->
        <link rel="stylesheet" href="../css/font-awesome.min.css">
        <!-- Normalize/Reset CSS-->
		<link rel="stylesheet" href="../css/normalize.min.css">
		<!-- Main CSS-->
        <link rel="stylesheet" href="../css/main.css">
		
    </head>
	
    <body id="welcome">
    
        <aside class="left-sidebar">
            <div class="logo">
                <a href="#welcome">
                    <img src="../img/SCM_logo.png" alt="">
                </a>
            </div>
            <nav class="left-nav">
                <ul id="nav">
                    <li class="current"><a href="#welcome">Welcome</a></li>
					<li><a href="#recursive-linked-lists">Recursive Linked Lists</a></li>
					<li><a class="indent" href="#recursive-linked-lists-double-linked">Recursive Double Linked List</a></li>
					<li><a class="indent" href="#recursive-linked-lists-circular-linked">Recursive Circular Linked List</a></li>
					<li><a class="indent" href="#recursive-linked-lists-circular-double-linked">Recursive Circular Double Linked List</a></li>
					<li><a href="#self-built-stacks">Self Created Stack</a></li>
					<li><a class="indent" href="#self-built-stacks-array">Stack Using an Array</a></li>
					<li><a class="indent" href="#self-built-stacks-linked-list">Stack Using a Linked List</a></li>
					<li><a href="#self-built-queue">Self Created Queue</a></li>
					<li><a class="indent" href="#self-built-queue-array">Queue Using an Array</a></li>
					<li><a class="indent" href="#self-built-queue-linked-list">Queue Using a Linked List</a></li>
                </ul>
            </nav>
        </aside>
		
		<div id="main-wrapper">
		    <div class="main-content">
		        <section id="welcome">
		            <div class="content-header">
		                <h1 class="big-title">Undergraduate Projects</h1>
						</br>
						<u><a target="_blank" href="university-undergraduate-contents.pdf"><h3>Click to View Table of Contents</h3></a></u>
						</br>
						<a class="" href="projects-2"><i class="fa fa-arrow-left"></i></a>
						<u><a class="not-page" href="projects-1">1</a></u>
						<u><a class="not-page" href="projects-2">2</a></u>
						<u><a class="" href="#">3</a></u>
						<a class="dead-arrow" href="#"><i class="fa fa-arrow-right"></i></a>
		            </div>
		            <div class="welcome">
                        
                        <h2 class="twenty">Assignments and Projects from My Undergraduate</h2>
						
						<p>Assignments and projects I felt were worth documenting/saving for the future. These aren't necessarily large or particularly important, but they show useful techniques or functions.</p>

                        <p>Some sections show whole programs or files, while other show only functions/methods that can be used in any program.</p>
						
						<p>I mark what programming language I use in each project as well.</p>
		            </div>
		            
		            <div class="features">
		                <h2 class="twenty">This Page Features</h2>
		                
		                <ul>
                            <li>Recursive Linked Lists</li>
							<li>Stacks | Arrays & Linked Lists</li>
							<li>Queues | Arrays & Linked Lists</li>
		                </ul>
		            </div>

		        </section>	        
				
				<section id="recursive-linked-lists">
					<div class="content-header">
		                <h1>Recursive Linked Lists</h1>
						</br>
						<h3>Programming Language : Java</h3>
                    </div>
					<div class="welcome">                      
                        <h2 class="twenty">Create and Manipulate Linked Lists Using Recursion</h2>
						<p>This program shows the use of recursion to manipulate linked lists.</p>
                        <p>The main recursive function in the list is traverse(Node start, int endIndex). It takes in a starting node, typically firstNode, and traverses to a given position. It returns the node at that position, which allows for easy variable editing on that particular node.</p>
		            </div>					
					<div class="welcome">       
                        <h2 class="twenty">Files Used / Created</h2>
                        <p>Download them below. Bold represents class files, unbold: interface or driver files.</p>
						<p>The Driver.java file shows examples of each method in the linked lists being used.</p>
		            </div>
					<div class="script-source">
		                <ul>
		                    <b><li><a href="project-files/page3/recursive-linked-lists/DoubleLinkedList.java" download>DoubleLinkedList.java</a></li></b>
							<b><li><a href="project-files/page3/recursive-linked-lists/CircularLinkedList.java" download>CircularLinkedList.java</a></li></b>
							<b><li><a href="project-files/page3/recursive-linked-lists/CircularDoubleLinkedList.java" download>CircularDoubleLinkedList.java</a></li></b>
							<li><a href="project-files/page3/recursive-linked-lists/ListInterface.java" download>ListInterface.java</a></li>
							<li><a href="project-files/page3/recursive-linked-lists/Driver.java" download>Driver.java</a></li>
		                </ul>
		            </div>
					<h2 class="title">ListInterface File</h2>
					<p class="fifteen">This is the Interface file for all of the linked lists displayed. It documents the methods that the lists will use.</p>
					<script type="syntaxhighlighter" class="brush: js">
					/**
					 * This is the interface for the Linked Lists using recursion
					 * CSC 210L Data Structures Lab
					 * Lab #5 - Recursive Linked Lists
					 * Semester 1 | Fall 2018
					 * October 10, 2018
					 * @author Joseph Hentges
					 */

					public interface ListInterface<T>
					{
					   /** Adds a new entry to the end of this list.
						   Entries currently in the list are unaffected.
						   The list's size is increased by 1.
						   @param newEntry  The object to be added as a new entry. 
						 */
					   public void add(T newEntry);
					   
					   /** Adds a new entry at a specified position within this list.
						   Entries originally at and above the specified position
						   are at the next higher position within the list.
						   The list's size is increased by 1.
						   @param newPosition  An integer that specifies the desired
											   position of the new entry.
						   @param newEntry     The object to be added as a new entry.
						   @throws  IndexOutOfBoundsException if either
									newPosition < 1 or newPosition > getLength() + 1. */
					   public void add(int newPosition, T newEntry);
					   
					   /** Removes the entry at a given position from this list.
						   Entries originally at positions higher than the given
						   position are at the next lower position within the list,
						   and the list's size is decreased by 1.
						   @param givenPosition  An integer that indicates the position of
												 the entry to be removed.
						   @return  A reference to the removed entry.
						   @throws  IndexOutOfBoundsException if either 
									givenPosition < 1 or givenPosition > getLength(). */
					   public T remove(int givenPosition);
					   
					   /** Removes all entries from this list. */
					   public void clear();
					   
					   /** Replaces the entry at a given position in this list.
						   @param givenPosition  An integer that indicates the position of
												 the entry to be replaced.
						   @param newEntry  The object that will replace the entry at the
											position givenPosition.
						   @return  The original entry that was replaced.
						   @throws  IndexOutOfBoundsException if either
									givenPosition < 1 or givenPosition > getLength(). */
					   public T replace(int givenPosition, T newEntry);
					   
					   /** Retrieves the entry at a given position in this list.
						   @param givenPosition  An integer that indicates the position of
												 the desired entry.
						   @return  A reference to the indicated entry.
						   @throws  IndexOutOfBoundsException if either
									givenPosition < 1 or givenPosition > getLength(). */
					   public T getEntry(int givenPosition);
					   
					   /** Retrieves all entries that are in this list in the order in which
						   they occur in the list.
						   @return  A newly allocated array of all the entries in the list.
									If the list is empty, the returned array is empty. */
					   public T[] toArray();
					   
					   /** Sees whether this list contains a given entry.
						   @param anEntry  The object that is the desired entry.
						   @return  True if the list contains anEntry, or false if not. */
					   public boolean contains(T anEntry);
					   
					   /** Gets the length of this list.
						   @return  The integer number of entries currently in the list. */
					   public int getLength();
						   
					   /** Sees whether this list is empty.
						   @return  True if the list is empty, or false if not. */
					   public boolean isEmpty();
					   
					   /**
						* Get values starting from the end of the list.
						* Will only be used in double linked lists types.
						*/
					   public void valuesFromEnd();
					   
					   /**
						* Get values in a circle. Runs through the list multiple times over.
						* This shows the list is connected from front to back.
						* Only used in circular linked lists types.
						*/
					   public void valuesInACircle();
					}
					</script>
					<section id="recursive-linked-lists-double-linked">
						<p class="addSpace">&nbsp;</p>
						<h2 class="title">DoubleLinkedList File</h2>
						<p class="fifteen">This is the class file for a Double Linked List. It creates a double linked list with nodes, and manipulates it using Recursion. Each node has a NEXT node and LAST node pointer.</p>
						<script type="syntaxhighlighter" class="brush: js">
						/**
						 * This is the class file for a Double Linked List using recursion
						 * CSC 210L Data Structures Lab
						 * Lab #5 - Recursive Linked Lists
						 * Semester 1 | Fall 2018
						 * October 10, 2018
						 * @author Joseph Hentges
						 */

						public class DoubleLinkedList<T> implements ListInterface<T> {
							
							private Node firstNode;            // Reference to first node of chain
							private int numberOfEntries;

							/**
							 * Traverse the list to a given position.
							 * @param current : Node - The node the traverse method is currently on
							 * @param position : int - The position number (index) the traverse is currently on
							 * @return Node - A node that the traverse method moves to
							 */
							public Node traverse(Node current, int position)
							{        
								if(position <= 1)
								{
									return current;
								}
								if(position > numberOfEntries)
								{
									position = numberOfEntries;
								}
								return traverse(current.getNextNode(), position-1);
								
							}
							
							/**
							 * Add item to the end of the list
							 * @param newEntry : T - item to be added
							 */
							@Override
							public void add(T newEntry) {
								//If the list is not empty
								//Need to find the end of the list
								Node newNode = new Node(newEntry);
								
								//If the list is empty set the first node pointer to this node
								if(numberOfEntries == 0)
								{
									firstNode = newNode;
								}
								else
								{
									Node lastNode = traverse(firstNode, numberOfEntries);
									newNode.setLastNode(lastNode);
									lastNode.setNextNode(newNode);           
								}
								numberOfEntries++;
							}

							/**
							 * Given a position, add the element to somewhere in the list
							 * @param newPosition : int - a given position
							 * @param newEntry : T - Some given data
							 */
							@Override
							public void add(int newPosition, T newEntry) {
								Node newNode = new Node(newEntry);
								
								if(newPosition > numberOfEntries)
								{
									add(newEntry);
									return;
								}
								if(newPosition <= 1) //Add to the beggining of the list
								{
									Node nodeTemp = firstNode;
									newNode.setNextNode(firstNode);
									firstNode = newNode;
									nodeTemp.setLastNode(firstNode);
								}
								else //Add the node to some place at the beginning or end of the list
								{
									Node lastNode = traverse(firstNode, newPosition-1);
									newNode.setLastNode(lastNode);
									newNode.setNextNode(lastNode.getNextNode());
									lastNode.setNextNode(newNode);
									newNode.getNextNode().setLastNode(newNode);
								}
								numberOfEntries++;
							}

							/**
							 * Remove the node at a given posiiton, and return its data
							 * @param givenPosition : int - The given position to have its node removed
							 * @return T : data - The data at the given position
							 */
							@Override
							public T remove(int givenPosition) {
								T data;
								//Check and set position entry
								if(givenPosition >= numberOfEntries)
								{
									givenPosition = numberOfEntries;
								}
								if(givenPosition <= 1)
								{
									data = firstNode.getData();
									firstNode = firstNode.getNextNode();
									firstNode.setLastNode(null);
									numberOfEntries--;
									return data;
								}
								Node theNode = traverse(firstNode, givenPosition); //Traverse to the node to be removed and returned
								Node nextNode = theNode.getNextNode();
								Node lastNode = theNode.getLastNode();
								data = theNode.getData();
								lastNode.setNextNode(nextNode);
								//Check to make sure nextNode is not null, will error if it tries to set the next node's last
								if(nextNode != null)
									nextNode.setLastNode(lastNode);
								numberOfEntries--;
								return data;
							}

							/**
							 * reset the list, clear of all nodes and set numberOfEntries to 0
							 */
							@Override
							public void clear() {
								initializeDataFields(); //call the methods that resets the list, and sets everything to 0
							}

							/**
							 * Replace the data at a given position
							 * @param givenPosition : int - given position
							 * @param newEntry : T - Data to be changed to in the given poistions node
							 * @return dataHold : T - The data originally in the node
							 */
							@Override
							public T replace(int givenPosition, T newEntry) {
								T dataHold;
								//Set the givenPosition if outside the list boundries
								if(givenPosition > numberOfEntries) //get the node's data
								{
									Node original = traverse(firstNode, numberOfEntries); //the node originally in the given position
									dataHold = original.getData();
									original.setData(newEntry);
								}
								if(givenPosition <= 1) //get first nodes data
								{
									 dataHold = firstNode.getData();
									 firstNode.setData(newEntry);
								}
								else //get somewhere in the middle of the lists data
								{
									Node original = traverse(firstNode, givenPosition); //the node originally in the given position
									dataHold = original.getData();
									original.setData(newEntry);
								}
								return dataHold;
							}

							/**
							 * Get the data of a node in a given position in the list
							 * @param givenPosition : int - index in the list
							 * @return data - data from the node of the given position in the list
							 */
							@Override
							public T getEntry(int givenPosition) {
								//Set the givenPosition if outside the list boundries
								if(givenPosition > numberOfEntries) //get the node's data
								{
									return traverse(firstNode, numberOfEntries).getData();
								}
								if(givenPosition <= 1) //get first nodes data
								{
									return firstNode.getData();
								}
								else //get somewhere in the middle of the lists data
								{
									return traverse(firstNode, givenPosition).getData();
								}
							}

							/**
							 * Get an array of the elements from the list
							 * @return output : T[] - an array of all the elements in the list
							 */
							@Override
							public T[] toArray() {
								T[] output = (T[]) new Object[numberOfEntries]; //array to be returned. Will contain the data in each node      
								
								int index = 0;
								Node currentNode = firstNode;
								output = copy(output, currentNode, index);
								
								return output;
							}
							
							/**
							 * This method recursively copies data from the linked list to an Array
							 * @param newArray Array which will eventually contain the elements in the list
							 * @param curr Node pointing to the current spot in the list
							 * @param index value for where we are in the list
							 * @return The updated array which now contains all the elements in the list
							 */
							private T[] copy(T[] newArray, Node current, int index)
							{
								if (index == numberOfEntries)
								{
									return newArray;
								}
								
								newArray = copy(newArray, current.getNextNode(), index + 1);
								newArray[index] = current.getData();
								return newArray;
							}

							/**
							 * Determine whether the list contains certain data
							 * @param anEntry : Node - data to be found the in the list
							 * @return found : boolean - whether the list contains certain data or not.
							 */
							@Override
							public boolean contains(T anEntry) {
								boolean found = false;
								Node currentNode = firstNode;

								if (find(anEntry, currentNode) != null)
									found = true;
								
								return found;
							}
							
							/**
							 * Recursively find a given data entry
							 * @param entry Data to find
							 * @param curr Current node to look at
							 * @return the Data we found (or a null if not found)
							 */
							private T find(T entry, Node curr)
							{
								if (curr == null)
									return null;
								
								if (entry.equals(curr.getData()))
									return curr.getData();
								
								return find(entry,curr.getNextNode());
							}

							/**
							 * Return the size of the list
							 * @return the size of the list
							 */
							@Override
							public int getLength() {
								return numberOfEntries;
							}

							/**
							 * Return whether the list is empty or not.
							 * @return result : boolean - whether the list is empty or not 
							 */
							@Override
							public boolean isEmpty() {
								boolean result = false;

								if (numberOfEntries == 0) // Or getLength() == 0
								{
									result = true;
								}

								return result;
							}

							/**
							 * Unused in this class
							 * Only used in circular linked lists
							 */
							@Override
							public void valuesInACircle() {
								System.out.println("NOT USED IN THIS TYPE OF LIST");
							}
							
							/**
							 * This is the constructor for a Node.
							 * It contains the node getter and setters for its variables (data, next and last)
							 */
							private class Node
							{

								private T data; // Entry in list
								private Node next; // Link to next node
								private Node last;

								private Node(T dataPortion)
								{
									data = dataPortion;
									next = null;
									last = null;
								} // end constructor

								private Node(T dataPortion, Node nextNode, Node lastNode)
								{
									data = dataPortion;
									next = nextNode;
									last = lastNode;
								}

								private T getData()
								{
									return data;
								} 

								private void setData(T newData)
								{
									data = newData;
								}

								private Node getNextNode()
								{
									return next;
								}

								private void setNextNode(Node nextNode)
								{
									next = nextNode;
								}
								
								private Node getLastNode()
								{
									return last;
								}
								
								private void setLastNode(Node lastNode)
								{
									last = lastNode;
								}
							} 
							
							/**
							 * Initializes the class data fields to indicate an empty list.
							 */
							private void initializeDataFields()
							{
								firstNode = null;
								numberOfEntries = 0;
							} // end initializeDataFields
							
							/**
							 * Go to the last node/element in the list, and read there data backwards.
							 * This shows the list is double linked.
							 * Non-Recursive since it is only used for testing
							 */
							@Override
							public void valuesFromEnd()
							{
								System.out.println("The number of elements: " + numberOfEntries);
								Node curr = firstNode;
								for(int i = 0; i < numberOfEntries-1; i++)
								{
									curr = curr.getNextNode();
								}
								System.out.println("The list is currently on the last item. Item data: " + curr.getData());
								System.out.println("Going backwards in the list now...");
								for(int i = 0; i < numberOfEntries; i++)
								{
									System.out.println("Current item data: " + curr.getData());
									curr = curr.getLastNode();
								}
							} 
						}
						</script>
					</section>
					<section id="recursive-linked-lists-circular-linked">
						<p class="addSpace">&nbsp;</p>
						<h2 class="title">CircularLinkedList File</h2>
						<p class="fifteen">This is the class file for a Circular Linked List. It creates a circular linked list with nodes, and manipulates it using Recursion. Each node has a NEXT node pointer, and the last node in the list points to the first node in the list.</p>
						<script type="syntaxhighlighter" class="brush: js">
						/**
						 * This is the class file for a Circular Linked List using recursion
						 * CSC 210L Data Structures Lab
						 * Lab #5 - Recursive Linked Lists
						 * Semester 1 | Fall 2018
						 * October 10, 2018
						 * @author Joseph Hentges
						 */

						public class CircularLinkedList<T> implements ListInterface<T> {
							
							private Node firstNode;            // Reference to first node of chain
							private int numberOfEntries;

							/**
							 * Traverse the list to a given position.
							 * @param current : Node - The node the traverse method is currently on
							 * @param position : int - The position number (index) the traverse is currently on
							 * @return Node - A node that the traverse method moves to
							 */
							public Node traverse(Node current, int position)
							{        
								if(position <= 1)
								{
									return current;
								}
								if(position > numberOfEntries)
								{
									position = numberOfEntries;
								}
								return traverse(current.getNextNode(), position-1);
								
							}
							
							/**
							 * Add item to the end of the list
							 * @param newEntry : T - item to be added
							 */
							@Override
							public void add(T newEntry) {
								Node newNode = new Node(newEntry);
								
								//If the list is empty set the first node pointer to this node
								if(numberOfEntries == 0)
								{
									firstNode = newNode;
								}
								else
								{
									Node lastNode = traverse(firstNode, numberOfEntries); //Get the last node in the list
									lastNode.setNextNode(newNode); //have the last node point to the new node
								}
								numberOfEntries++;
							}

							/**
							 * Given a position, add the element to somewhere in the list
							 * @param newPosition : int - a given position
							 * @param newEntry : T - Some given data
							 */
							@Override
							public void add(int newPosition, T newEntry) {
								Node newNode = new Node(newEntry);
								
								if(newPosition > numberOfEntries) //add to the end of the list
								{
									add(newEntry);
									return;
								}
								if(newPosition <= 1) //Add to the beggining of the list
								{
									Node nodeTemp = firstNode;
									newNode.setNextNode(firstNode);
									firstNode = newNode;
								}
								else //Add the node to some place at the beginning or end of the list
								{
									Node lastNode = traverse(firstNode, newPosition-1);
									newNode.setNextNode(lastNode.getNextNode());
									lastNode.setNextNode(newNode);
								}
								numberOfEntries++;
							}

							/**
							 * Remove the node at a given posiiton, and return its data
							 * @param givenPosition : int - The given position to have its node removed
							 * @return T : data - The data at the given position
							 */
							@Override
							public T remove(int givenPosition) {
								T data;
								//Check and set position
								if(givenPosition >= numberOfEntries) //remove the last entry in the list
								{
									givenPosition = numberOfEntries;
								}
								if(givenPosition <= 1) //remove the first entry in the list
								{
									data = firstNode.getData();
									traverse(firstNode, numberOfEntries).setNextNode(firstNode.getNextNode()); //set the last nodes next pointer to point to firstNodes next node
									firstNode = firstNode.getNextNode(); //change the first pointer to point to firstNode's next
									numberOfEntries--;
									return data;
								}
								//Remove the last or a middle entry in the list
								Node theNode = traverse(firstNode, givenPosition-1); //Traverse to the node before the node to be removed and returned
								data = theNode.getNextNode().getData();
								theNode.setNextNode(theNode.getNextNode().getNextNode());
								numberOfEntries--;
								return data;
							}

							/**
							 * Cleat the list of all data.
							 * Set the numberOfEntries variable to 0
							 */
							@Override
							public void clear() {
								initializeDataFields();
							}

							/**
							 * Replace the data at a given position
							 * @param givenPosition : int - given position
							 * @param newEntry : T - Data to be changed to in the given positions node
							 * @return dataHold : T - The data originally in the node
							 */
							@Override
							public T replace(int givenPosition, T newEntry) {
								T dataHold;
								//Set the givenPosition if outside the list boundries
								if(givenPosition > numberOfEntries) //get the node's data
								{
									Node original = traverse(firstNode, numberOfEntries); //the node originally in the given position
									dataHold = original.getData();
									original.setData(newEntry);
								}
								if(givenPosition <= 1) //get first nodes data
								{
									 dataHold = firstNode.getData();
									 firstNode.setData(newEntry);
								}
								else //get somewhere in the middle of the lists data
								{
									Node original = traverse(firstNode, givenPosition); //the node originally in the given position
									dataHold = original.getData();
									original.setData(newEntry);
								}
								return dataHold;
							}

							/**
							 * Get the data of a node in a given position in the list
							 * @param givenPosition : int - index in the list
							 * @return data - data from the node of the given position in the list
							 */
							@Override
							public T getEntry(int givenPosition) {
								//Set the givenPosition if outside the list boundries
								if(givenPosition > numberOfEntries) //get the node's data
								{
									return traverse(firstNode, numberOfEntries).getData();
								}
								if(givenPosition <= 1) //get first nodes data
								{
									return firstNode.getData();
								}
								else //get somewhere in the middle of the lists data
								{
									return traverse(firstNode, givenPosition).getData();
								}
							}

							/**
							 * Get an array of the elements from the list
							 * @return output : T[] - an array of all the elements in the list
							 */
							@Override
							public T[] toArray() {
								T[] output = (T[]) new Object[numberOfEntries]; //array to be returned. Will contain the data in each node      
								
								int index = 0;
								Node currentNode = firstNode;
								output = copy(output, currentNode, index);
								
								return output;
							}
							
							/**
							 * This method recursively copies data from the linked list to an Array
							 * @param newArray Array which will eventually contain the elements in the list
							 * @param curr Node pointing to the current spot in the list
							 * @param index value for where we are in the list
							 * @return The updated array which now contains all the elements in the list
							 */
							private T[] copy(T[] newArray, Node current, int index)
							{
								if (index == numberOfEntries)
								{
									return newArray;
								}
								
								newArray = copy(newArray, current.getNextNode(), index + 1);
								newArray[index] = current.getData();
								return newArray;
							}

							/**
							 * Determine whether the list contains certain data
							 * @param anEntry : Node - data to be found the in the list
							 * @return found : boolean - whether the list contains certain data or not.
							 */
							@Override
							public boolean contains(T anEntry) {
								boolean found = false;
								Node currentNode = firstNode;

								if (find(anEntry, currentNode, 1) != null)
									found = true;
								
								return found;
							}
							
							/**
							 * Recursively find a given data entry
							 * @param entry Data to find
							 * @param curr Current node to look at
							 * @return the Data we found (or a null if not found)
							 */
							private T find(T entry, Node curr, int count)
							{
								if (curr == null || count == numberOfEntries+1)
									return null;
								
								if (entry.equals(curr.getData()))
									return curr.getData();
								
								return find(entry,curr.getNextNode(), count+1);
							}

							/**
							 * Get the length of the list
							 * @return numberOfEntries : the length of the list
							 */
							@Override
							public int getLength() {
								return numberOfEntries;
							}

							/**
							 * return whether the list is empty or not
							 * @return boolean -  the list is empty or not
							 */
							@Override
							public boolean isEmpty() {
								return numberOfEntries <= 0;
							}

							/**
							 * Unused in this class
							 * Only used in double linked lists
							 */
							@Override
							public void valuesFromEnd() {
								System.out.println("NOT USED IN THIS TYPE OF LIST");
							}

							/**
							 * Use this method to show the linked list is circular
							 * Non-Recursive since it is only used for testing
							 */
							@Override
							public void valuesInACircle() {
								System.out.println("Get values in a cirlce. Starting from the first node.");
								Node curr = firstNode;
								for(int i = 0; i < numberOfEntries*3; i++)
								{
									System.out.println("Current item data:" + curr.data);
									curr = curr.next;
								}
							}
							
							/**
							 * This is the constructor for a Node.
							 * It contains the node getter and setters for its variables (data and next)
							 */
							private class Node
							{

								private T data; // Entry in list
								private Node next; // Link to next node

								private Node(T dataPortion)
								{
									data = dataPortion;
									next = firstNode;
								} // end constructor

								private Node(T dataPortion, Node nextNode)
								{
									data = dataPortion;
									next = nextNode;
								}

								private T getData()
								{
									return data;
								} 

								private void setData(T newData)
								{
									data = newData;
								}

								private Node getNextNode()
								{
									return next;
								}

								private void setNextNode(Node nextNode)
								{
									next = nextNode;
								}
							} 
							
							/**
							 * Initializes the class data fields to indicate an empty list.
							 */
							private void initializeDataFields()
							{
								firstNode = null;
								numberOfEntries = 0;
							}
						}
						</script>
					</section>
					<section id="recursive-linked-lists-circular-double-linked">
						<p class="addSpace">&nbsp;</p>
						<h2 class="title">CircularDoubleLinkedList File</h2>
						<p class="fifteen">This is the class file for a Circular Double Linked List. It creates a circular double linked list with nodes, and manipulates it using Recursion. Each node has a NEXT node, and LAST node pointer. 
						The first node in the lists last node points to the last node in the list, and the last node in the list points to the first node in the list.</p>
						<script type="syntaxhighlighter" class="brush: js">
						/**
						 * This is the class file for a Circular Double Linked List using recursion
						 * CSC 210L Data Structures Lab
						 * Lab #5 - Recursive Linked Lists
						 * Semester 1 | Fall 2018
						 * October 10, 2018
						 * @author Joseph Hentges
						 */

						public class CircularDoubleLinkedList<T> implements ListInterface<T> {
							
							private Node firstNode;            // Reference to first node of chain
							private int numberOfEntries;

							/**
							 * Traverse the list to a given position.
							 * @param current : Node - The node the traverse method is currently on
							 * @param position : int - The position number (index) the traverse is currently on
							 * @return Node - A node that the traverse method moves to
							 */
							public Node traverse(Node current, int position)
							{        
								if(position <= 1)
								{
									return current;
								}
								if(position > numberOfEntries)
								{
									position = numberOfEntries;
								}
								return traverse(current.getNextNode(), position-1);
								
							}

							/**
							 * Add item to the end of the list
							 * @param newEntry : T - item to be added
							 */
							@Override
							public void add(T newEntry) {
								//If the list is not empty
								//Need to find the end of the list
								Node newNode = new Node(newEntry);
								
								//If the list is empty set the first node pointer to this node
								if(numberOfEntries == 0)
								{
									firstNode = newNode;
								}
								else
								{
									Node lastNode = traverse(firstNode, numberOfEntries);
									newNode.setLastNode(lastNode);
									newNode.setNextNode(firstNode);
									lastNode.setNextNode(newNode);
									firstNode.setLastNode(newNode);
									numberOfEntries++;         
									return;
								}
								numberOfEntries++;
							}

							/**
							 * Given a position, add the element to somewhere in the list
							 * @param newPosition : int - a given position
							 * @param newEntry : T - Some given data
							 */
							@Override
							public void add(int newPosition, T newEntry) {
								Node newNode = new Node(newEntry);
								
								if(newPosition > numberOfEntries)
								{
									add(newEntry);
									return;
								}
								if(newPosition <= 1) //Add to the beggining of the list
								{
									Node nodeTemp = firstNode;
									newNode.setNextNode(firstNode);
									newNode.setLastNode(firstNode.getLastNode());
									firstNode.getLastNode().setNextNode(newNode);
									firstNode = newNode;
									nodeTemp.setLastNode(firstNode);
								}
								else //Add the node to some place at the beginning or end of the list
								{
									Node lastNode = traverse(firstNode, newPosition-1);
									newNode.setLastNode(lastNode);
									newNode.setNextNode(lastNode.getNextNode());
									lastNode.setNextNode(newNode);
									newNode.getNextNode().setLastNode(newNode);
								}
								numberOfEntries++;
							}

							/**
							 * Remove the node at a given posiiton, and return its data
							 * @param givenPosition : int - The given position to have its node removed
							 * @return T : data - The data at the given position
							 */
							@Override
							public T remove(int givenPosition) {
								T data;
								//Check and set position entry
								if(givenPosition > numberOfEntries)
								{
									givenPosition = numberOfEntries;
								}
								if(givenPosition <= 1)
								{
									data = firstNode.getData();
									firstNode.getNextNode().setLastNode(firstNode.getLastNode());
									firstNode = firstNode.getNextNode();
									numberOfEntries--;
									return data;
								}
								Node theNode = traverse(firstNode, givenPosition); //Traverse to the node to be removed and returned
								theNode.getNextNode().setLastNode(theNode.getLastNode());
								theNode.getLastNode().setNextNode(theNode.getNextNode());
								//If the last entry is the one being removed, set its last entry to have a next entry of the first node
								if(givenPosition >= numberOfEntries)
								{
									theNode.getLastNode().setNextNode(firstNode);
								}
								data = theNode.getData();
								numberOfEntries--;
								return data;
							}

							/**
							 * Clear the list of all values
							 */
							@Override
							public void clear() {
								initializeDataFields();
							}

							/**
							 * Replace the data at a given position
							 * @param givenPosition : int - given position
							 * @param newEntry : T - Data to be changed to in the given poistions node
							 * @return dataHold : T - The data originally in the node
							 */
							@Override
							public T replace(int givenPosition, T newEntry) {
								T dataHold;
								//Set the givenPosition if outside the list boundries
								if(givenPosition > numberOfEntries) //get the node's data
								{
									Node original = traverse(firstNode, numberOfEntries); //the node originally in the given position
									dataHold = original.getData();
									original.setData(newEntry);
								}
								if(givenPosition <= 1) //get first nodes data
								{
									 dataHold = firstNode.getData();
									 firstNode.setData(newEntry);
								}
								else //get somewhere in the middle of the lists data
								{
									Node original = traverse(firstNode, givenPosition); //the node originally in the given position
									dataHold = original.getData();
									original.setData(newEntry);
								}
								return dataHold;
							}

							/**
							 * Get the data of a node in a given position in the list
							 * @param givenPosition : int - index in the list
							 * @return data - data from the node of the given position in the list
							 */
							@Override
							public T getEntry(int givenPosition) {
								//Set the givenPosition if outside the list boundries
								if(givenPosition > numberOfEntries) //get the node's data
								{
									return traverse(firstNode, numberOfEntries).getData();
								}
								if(givenPosition <= 1) //get first nodes data
								{
									return firstNode.getData();
								}
								else //get somewhere in the middle of the lists data
								{
									return traverse(firstNode, givenPosition).getData();
								}
							}

							/**
							 * Get an array of the elements from the list
							 * @return output : T[] - an array of all the elements in the list
							 */
							@Override
							public T[] toArray() {
								T[] output = (T[]) new Object[numberOfEntries]; //array to be returned. Will contain the data in each node      
								
								int index = 0;
								Node currentNode = firstNode;
								output = copy(output, currentNode, index);
								
								return output;
							}
							
							/**
							 * This method recursively copies data from the linked list to an Array
							 * @param newArray Array which will eventually contain the elements in the list
							 * @param curr Node pointing to the current spot in the list
							 * @param index value for where we are in the list
							 * @return The updated array which now contains all the elements in the list
							 */
							private T[] copy(T[] newArray, Node current, int index)
							{
								if (index == numberOfEntries)
								{
									return newArray;
								}
								
								newArray = copy(newArray, current.getNextNode(), index + 1);
								newArray[index] = current.getData();
								return newArray;
							}

							/**
							 * Determine whether the list contains certain data
							 * @param anEntry : Node - data to be found the in the list
							 * @return found : boolean - whether the list contains certain data or not.
							 */
							@Override
							public boolean contains(T anEntry) {
								boolean found = false;
								Node currentNode = firstNode;

								if (find(anEntry, currentNode, 1) != null)
									found = true;
								
								return found;
							}
							
							/**
							 * Recursively find a given data entry
							 * @param entry Data to find
							 * @param curr Current node to look at
							 * @return the Data we found (or a null if not found)
							 */
							private T find(T entry, Node curr, int count)
							{
								if (curr == null || count == numberOfEntries+1)
									return null;
								
								if (entry.equals(curr.getData()))
									return curr.getData();
								
								return find(entry,curr.getNextNode(), count+1);
							}

							/**
							 * Get the length of the list
							 * @return numberOfEntries - The number of elements in the list
							 */
							@Override
							public int getLength() {
								return numberOfEntries;
							}

							/**
							 * Return whether the list is empty or not
							 * @return boolean - whether the list is empty
							 */
							@Override
							public boolean isEmpty() {
								return numberOfEntries <= 0;
							}

							/**
							 * Go to the last node/element in the list, and read there data backwards.
							 * This shows the list is double linked.
							 * Non-Recursive since it is only used for testing
							 */
							@Override
							public void valuesFromEnd()
							{
								System.out.println("The number of elements: " + numberOfEntries);
								Node curr = firstNode;
								for(int i = 0; i < numberOfEntries-1; i++)
								{
									curr = curr.getNextNode();
								}
								System.out.println("The list is currently on the last item. Item data: " + curr.getData());
								System.out.println("Going backwards in the list now...");
								for(int i = 0; i < numberOfEntries; i++)
								{
									System.out.println("Current item data: " + curr.getData());
									curr = curr.getLastNode();
								}
							}

							/**
							 * Use this method to show the linked list is circular
							 * Non-Recursive since it is only used for testing
							 */
							@Override
							public void valuesInACircle() {
								System.out.println("Get values in a cirlce. Starting from the first node.");
								Node curr = firstNode;
								for(int i = 0; i < numberOfEntries*3; i++)
								{
									System.out.println("Current item data:" + curr.data);
									curr = curr.next;
								}
							}
							
							
							/**
							 * This is the constructor for a Node.
							 * It contains the node getter and setters for its variables (data, next and last)
							 */
							private class Node
							{

								private T data; // Entry in list
								private Node next; // Link to next node
								private Node last;

								private Node(T dataPortion)
								{
									data = dataPortion;
									next = firstNode;
									last = firstNode;
								} // end constructor

								private Node(T dataPortion, Node nextNode, Node lastNode)
								{
									data = dataPortion;
									next = nextNode;
									last = lastNode;
								}

								private T getData()
								{
									return data;
								} 

								private void setData(T newData)
								{
									data = newData;
								}

								private Node getNextNode()
								{
									return next;
								}

								private void setNextNode(Node nextNode)
								{
									next = nextNode;
								}
								
								private Node getLastNode()
								{
									return last;
								}
								
								private void setLastNode(Node lastNode)
								{
									last = lastNode;
								}
							} 
							
							/**
							 * Initializes the class data fields to indicate an empty list.
							 */
							private void initializeDataFields()
							{
								firstNode = null;
								numberOfEntries = 0;
							}
						}
						</script>
					</section>
		        </section>
				
				<section id="self-built-stacks">
					<div class="content-header">
		                <h1>Stacks | Arrays and Linked Lists</h1>
						</br>
						<h3>Programming Language : Java</h3>
                    </div>
					<div class="welcome">                      
                        <h2 class="twenty">Create a Stack Using Arrays and Linked Lists</h2>
						<p>This program shows the use of arrays and linked lists to create a stack.</p>
                        <p>The stack allows for data to be added (push), peeked, removed (pop), and a few other functions.</p>
		            </div>
					<div class="welcome">       
                        <h2 class="twenty">Files Used / Created</h2>
                        <p>Download them below. Bold represents class files, unbold: interface files.</p>
		            </div>
					<div class="script-source">
		                <ul>
							<b><li><a href="project-files/page3/self-built-stacks/ArrayStack.java" download>ArrayStack.java</a></li></b>
							<b><li><a href="project-files/page3/self-built-stacks/LinkedStack.java" download>LinkedStack.java</a></li></b>
		                    <li><a href="project-files/page3/self-built-stacks/MyStack.java" download>myStack.java</a></li>
		                </ul>
		            </div>					
					<p class="addSpace">&nbsp;</p>
					<h2 class="title">myStack | Interface File</h2>
					<p class="fifteen">This is the interface file for the stacks created using arrays and linked lists. Methods needed for a stack are declared here.</p>
					<script type="syntaxhighlighter" class="brush: js">
					/**
					 * This is the interface file for a Stack.
					 * CSC 210 Data Structures
					 * Stacks
					 * Semester 1 | Fall 2018
					 * October 12, 2018
					 * @author Joseph Hentges
					 */

					public interface MyStack<T>
					{
						/**
						 * Pushes data onto the top of the Stack
						 * @param entry Data to push onto the Stack
						 */
						void push(T entry);

						/**
						 * Pop data off the top of the Stack.
						 * @return Data which was on the top of the Stack. May be null if Stack is empty
						 */
						T pop();
						
						/**
						 * Peek at what data is on top of the Stack
						 * @return Data (does not remove) which is currently on top of the Stack.  May be null if Stack is empty
						 */
						T peek();
						
						/**
						 * Retrieves the size of the Stack
						 * @return An integer denoting how many items are currently in the Stack
						 */
						int size();
						
						/**
						 * Determines if the Stack is empty or not
						 * @return Boolean indicating if the Stack is empty (true) or not (false)
						 */
						boolean isEmpty();
					}
					</script>
					<section id="self-built-stacks-array">
						<p class="addSpace">&nbsp;</p>
						<h2 class="title">ArrayStack | Class File</h2>
						<p class="fifteen">This is the class file for a stack using arrays.</p>
						<script type="syntaxhighlighter" class="brush: js">
						/**
						 * This is the class file for a Stack using arrays. 
						 * This stack is NOT RESIZABLE
						 * CSC 210L Data Structures Lab
						 * Stacks
						 * Semester 1 | Fall 2018
						 * October 12, 2018
						 * @author Joseph Hentges
						 */
						public class ArrayStack<T>  implements MyStack<T>
						{

							private T[] stack;
							private int count;
							
							/**
							 * the constructor for this file
							 * @param size 
							 */
							public ArrayStack(int size)
							{
								count = 0;
								stack = (T[]) new Object[size];
							}
							
							/**
							 * This is a toString method to get (for display) the values in the stack
							 * @return output : String - the string of the values
							 */
							public String toString()
							{
								String output = "PRINTING STACK\n";
								for (int i = count - 1; i >= 0; i--)
								{
									output += "\t" + stack[i] + "\n";
								}
								output += "There are " + size() + " items.\n";
								return output;
							}
							
							/**
							 * Add (push on) some data to the stack
							 * @param entry : T - some data (type not specified)
							 */
							@Override
							public void push(T entry) {
								if (count == stack.length) //Check if full!
								{
									System.err.println("Stack full, did not push!");
									return;
								}
								
								stack[count] = entry;
								count++;
								
							}

							/**
							 * Remove (pop off) the first value in the stack
							 * @return temp : T - the data that was removed (type not specified)
							 */
							@Override
							public T pop() {
								if (isEmpty())
								{
									return null;
								}
								count--;
								T temp = stack[count];
								stack[count] = null;
								return temp;
							}

							/**
							 * Look (peek) at the first value in the stack
							 * @return temp : T - the first data in the stack
							 */
							@Override
							public T peek() {
								if (isEmpty())
								{
									return null;
								}
								return stack[count - 1];
							}

							/**
							 * Get the size of the stack
							 * @return count : int - the size of the stack
							 */
							@Override
							public int size() {
								return count;
							}

							/**
							 * return whether the stack is empty or not
							 * @return bool : boolean - the stack is empty or not
							 */
							@Override
							public boolean isEmpty() {
								if (count == 0)
									return true;
								return false;
							}
							
						}
						</script>
					</section>
					<section id="self-built-stacks-linked-list">
						<p class="addSpace">&nbsp;</p>
						<h2 class="title">LinkedStack | Class File</h2>
						<p class="fifteen">This is the class file for a stack using linked lists.</p>
						<script type="syntaxhighlighter" class="brush: js">
						/**
						 * This is the class file for a Stack using Linked Lists.
						 * This stack IS RESIZABLE
						 * CSC 210 Data Structures
						 * Stacks
						 * Semester 1 | Fall 2018
						 * October 12, 2018
						 * @author Joseph Hentges
						 */

						public class LinkedStack<T> implements MyStack<T> {
							
							private int count;
							private Node top;
							
							/**
							 * This is the class for a Node, for the linked list
							 */
							private class Node
							{
								T data;
								Node next;
							}
							
							/**
							 * This is the constructor for the LinkedStack
							 */
							public LinkedStack()
							{
								count = 0;
								top = null;
							}

							/**
							 * This is a toString method to get (for display) the values in the stack
							 * @return output : String - the string of the values
							 */
							public String toString()
							{
								String output = "PRINTING STACK\n";
								Node curr = top;
								while (curr != null)
								{
									output += "\t" + curr.data + "\n";
									curr = curr.next;
								}
								output += "Current size is: " + size() + "\n";
								return output;
							}
							
							/**
							 * Add (push on) some entry to the stack
							 * @param entry : T - Some data (type not specified)
							 */
							@Override
							public void push(T entry) {
								Node newNode = new Node();
								newNode.data = entry;
								newNode.next = top;
								top = newNode;
								count++;
							}

							/**
							 * Remove (pop off) some entry from the queue
							 * @return temp : T - Some data (type not specified)
							 */
							@Override
							public T pop() {
								if (isEmpty())
									return null;
								T temp = top.data;
								top.data = null;
								top = top.next;
								count--;
								return temp;
							}

							/**
							 * Peek, not remove, the first value in the stack
							 * @return T - some data (type not specified)
							 */
							@Override
							public T peek() {
								if (isEmpty())
									return null;
								return top.data;
							}

							/**
							 * Get the size of the stack
							 * @return count : int - the size of the stack
							 */
							@Override
							public int size() {
								return count;
							}

							/**
							 * return whether the stack is empty or not
							 * @return bool : boolean - the stack empty or not.
							 */
							@Override
							public boolean isEmpty() {
								if (count == 0)
									return true;
								return false;
							}
							
						}
						</script>
					</section>
		        </section>
				
				<section id="self-built-queue">
					<div class="content-header">
		                <h1>Queues | Arrays and Linked Lists</h1>
						</br>
						<h3>Programming Language : Java</h3>
                    </div>
					<div class="welcome">                      
                        <h2 class="twenty">Create a Queue Using Arrays and Linked Lists</h2>
						<p>This program shows the use of arrays and linked lists to create a queue.</p>
                        <p>The queue allows for data to be added (enqueue), peeked, removed (dequeue), and a few other functions.</p>
		            </div>
					<div class="welcome">       
                        <h2 class="twenty">Files Used / Created</h2>
                        <p>Download them below. Bold represents class files, unbold: interface files.</p>
		            </div>
					<div class="script-source">
		                <ul>
							<b><li><a href="project-files/page3/self-built-queue/ArrayQueue.java" download>ArrayQueue.java</a></li></b>
							<b><li><a href="project-files/page3/self-built-queue/LinkedQueue.java" download>LinkedQueue.java</a></li></b>
		                    <li><a href="project-files/page3/self-built-queue/MyQueue.java" download>myQueue.java</a></li>
		                </ul>
		            </div>					
					<p class="addSpace">&nbsp;</p>
					<h2 class="title">myQueue | Interface File</h2>
					<p class="fifteen">This is the interface file for the queues created using arrays and linked lists. Methods needed for a queue are declared here.</p>
					<script type="syntaxhighlighter" class="brush: js">
					/**
					 * This is the interface file for a Queue.
					 * CSC 210 Data Structures
					 * Queues
					 * Semester 1 | Fall 2018
					 * October 12, 2018
					 * @author Joseph Hentges
					 */

					public interface MyQueue<T>
					{
						/**
						 * Enqueues data at the back of the Queue
						 * @param entry Data to enqueue into the Queue
						 */
						void enqueue(T entry);

						/**
						 * Dequeue data off the front of the Queue
						 * @return Data which was at the front of the Queue. May be null if Queue is empty
						 */
						T dequeue();
						
						/**
						 * Peek at what data is at the front of the Queue
						 * @return Data (does not remove) which is currently at the front of the Queue.  May be null if Queue is empty
						 */
						T peek();
						
						/**
						 * Retrieves the size of the Queue
						 * @return An integer denoting how many items are currently in the Queue
						 */
						int size();
						
						/**
						 * Determines if the Queue is empty or not
						 * @return Boolean indicating if the Queue is empty (true) or not (false)
						 */
						boolean isEmpty();
					}
					</script>
					<section id="self-built-queue-array">
						<p class="addSpace">&nbsp;</p>
						<h2 class="title">ArrayQueue | Class File</h2>
						<p class="fifteen">This is the class file for a queue using arrays.</p>
						<script type="syntaxhighlighter" class="brush: js">				
						/**
						 * This is the class file for a Queue using Arrays. 
						 * This Queue is NOT RESIZABLE
						 * CSC 210 Data Structures
						 * Queues
						 * Semester 1 | Fall 2018
						 * October 12, 2018
						 * @author Joseph Hentges
						 */

						public class ArrayQueue<T> implements MyQueue<T> {
							private int count;
							private int front;
							private int back;
							private T[] queue;
							
							/**
							 * This is the constructor
							 * @param size : int - the size of the array
							 */
							public ArrayQueue(int size)
							{
								count = 0;
								queue = (T[]) new Object[size];
								front = 0;
								back = 0;
							}
							
							/**
							 * This is a toString method to get (for display) the values in the queue
							 * @return output : String - the string of the values
							 */
							public String toString()
							{
								String output = "PRINTING QUEUE\n";
								//if the queue is empty, don't do anything
								if(isEmpty())
								{
									//DO NOTHING
								}
								// the queue is not wrapping
								else if(front <= back)
								{
									for(int i = front; i <= back; i++)
									{
										output += "\t" + queue[i] + "\t";
									}
								}
								// the queue is wrapping
								else
								{
									// go from front to end of array
									for(int i = front; i < queue.length; i++)
									{
										output += "\t" + queue[i] + "\t";
									}
									// pick the front (0 to back)
									for(int i = 0; i <= back; i++)
									{
										output += "\t" + queue[i] + "\t";
									}
								}
								output += "\nThere are " + size() + " items.\n";
								return output;
							}

							/**
							 * Add an entry to the queue
							 * @param entry : T - Some data (data type - any)
							 */
							@Override
							public void enqueue(T entry) {
								//if the queue is full, let the user know, and don't insert any values.
								if (count == queue.length)
								{
									System.err.println("Queue is FULL!!!");
									return;
								}
								//if the queue is empty, place the value in the first index of the array (0)
								if (isEmpty())
								{
									front = 0;
									back = 0;
									queue[front] = entry;
									count++;
									return;
								}
								//if back is less than the length of the queue (meaning the array filling from left to right, and not full). Place the value at index back
								if(back < queue.length - 1)
								{
									back++;
									queue[back] = entry;
									count++;
									return;
								}
								//at the end of the array, but not FULL, do a wrap around. Meaning we place the values at the front rather than the back
								back = 0;
								queue[back] = entry;
								count++;
								
							}

							/**
							 * Remove an entry from the queue and return the data
							 * @return temp : T - some data that was removed from the queue
							 */
							@Override
							public T dequeue() {
								//if the queue is empty, return nothing
								if(isEmpty())
								{
									return null;
								}
								T temp = queue[front];
								queue[front] = null;
								count--;
								front++;
								//If the front index is now out of bounds (front larger than the size of the array, set it back to 0
								if(front == queue.length)
								{
									front = 0;
								}
								return temp;
							}

							/**
							 * Look (peek) at the next value in the queue
							 * @return T - some data, the front of the queue
							 */
							@Override
							public T peek() {
								return queue[front];
							}

							/**
							 * Get the size of the queue
							 * @return count : int  - the size of the queue
							 */
							@Override
							public int size() {
								return count;
							}

							/**
							 * Return whether the queue is empty or not
							 * @return bool : boolean - the queue is empty or not
							 */
							@Override
							public boolean isEmpty() {
								return count == 0;
							}
							
						}
						</script>
					</section>
					<section id="self-built-queue-linked-list">
						<p class="addSpace">&nbsp;</p>
						<h2 class="title">LinkedQueue | Class File</h2>
						<p class="fifteen">This is the class file for a Queue using linked lists.</p>
						<script type="syntaxhighlighter" class="brush: js">
						/**
						 * This is the class file for a Queue using Linked Lists. 
						 * This Queue is RESIZABLE
						 * CSC 210 Data Structures
						 * Queues
						 * Semester 1 | Fall 2018
						 * October 12, 2018
						 * @author Joseph Hentges
						 */

						public class LinkedQueue<T> implements MyQueue<T> {

							private int count;
							private Node front;
							private Node back;
							
							//class for a Node
							private class Node
							{
								T data;
								Node next = null;
							}
							
							/**
							 * Constructor for a Linked Queue
							 */
							public LinkedQueue()
							{
								count = 0;
								front = null;
								back = null;
							}
							
							/**
							 * This is a toString method to get (for display) the values in the queue
							 * @return output : String - the string of the values
							 */
							public String toString()
							{
								String output = "PRINTING QUEUE\n";
								Node curr = front;
								while (curr != null)
								{
									output += "\t" + curr.data + "\t";
									curr = curr.next;
								}
								output += "\nCurrent size is: " + size() + "\n";
								return output;
							}
							
							/**
							 * Add an entry to the queue
							 * @param entry : T - Some data (data type - any)
							 */
							@Override
							public void enqueue(T entry) {
								Node newNode = new Node();
								newNode.data = entry;
								//if the queue is empty, place the node at the front of the queue
								if(isEmpty())
								{
									front = newNode;
								}
								//if the queue is not empty, place the node at the end of the queue
								else
								{
									back.next = newNode;
								}
								back = newNode; //point back to the new node
								count++;
							}

							/**
							 * Remove an entry from the queue and return the data
							 * @return temp : T - some data that was removed from the queue
							 */
							@Override
							public T dequeue() {
								//if the queue is empty, return nothing
								if(isEmpty())
								{
									return null;
								}
								//if the queue is not empty, get the front data and move its pointer
								T temp = front.data;
								front.data = null;
								front = front.next;
								count--;
								//if we are empty after a removal, back will still be pointing to the node, so set that to null, to account for it
								if(isEmpty())
								{
									back = null;
								}
								return temp;
							}

							/**
							 * Get the front data in the queue
							 * @return T : the data (type not specified)
							 */
							@Override
							public T peek() {
								if(isEmpty())
								{
									return null;
								}
								return front.data;
							}

							/**
							 * Get the size of the queue
							 * @return count : int  - the size of the queue
							 */
							@Override
							public int size() {
								return count;
							}

							/**
							 * return whether the queue is empty or not
							 * @return bool : boolean - whether the queue is empty
							 */
							@Override
							public boolean isEmpty() {
								return count == 0;
							}
							
						}
						</script>
					</section>
		        </section>


		        
		        <section id="end">
					<div class="content-header">
		                <a class="" href="projects-2"><i class="fa fa-arrow-left"></i></a>
						<u><a class="not-page" href="projects-1">1</a></u>
						<u><a class="not-page" href="projects-2">2</a></u>
						<u><a class="" href="#">3</a></u>
						<a class="dead-arrow" href="#"><i class="fa fa-arrow-right"></i></a>
                    </div>
		        </section>
		    </div>
		</div>
		
		
		<!-- Essential JavaScript Libraries
		==============================================-->
        <script type="text/javascript" src="../js/jquery-1.11.0.min.js"></script>
        <script type="text/javascript" src="../js/jquery.nav.js"></script>
        <script type="text/javascript" src="../syntax-highlighter/scripts/shCore.js"></script> 
        <script type="text/javascript" src="../syntax-highlighter/scripts/shBrushXml.js"></script> 
        <script type="text/javascript" src="../syntax-highlighter/scripts/shBrushCss.js"></script> 
        <script type="text/javascript" src="../syntax-highlighter/scripts/shBrushJScript.js"></script> 
        <script type="text/javascript" src="../syntax-highlighter/scripts/shBrushPhp.js"></script> 
        <script type="text/javascript">
            SyntaxHighlighter.all()
        </script>
        <script type="text/javascript" src="../js/custom.js"></script>
		
    </body>
</html>
